/* Name: sw-uart.c
 * Project: AVR USB driver for CDC interface on Low-Speed USB
 * Author: Osamu Tamura
 * Creation Date: 2006-06-22
 * Tabsize: 4
 * Copyright: (c) 2006 by Recursion Co., Ltd.
 * License: Proprietary, free under certain conditions. See Documentation.
 *
 *  2006-07-10 software-UART interrupt handling time reduced.
 */

/*
General Description:
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include "oddebug.h"
#include "uart.h"

#if !UART_CFG_HAVE_USART

/* UART buffer */
uchar    urptr, uwptr, irptr, iwptr;
uchar    rx_buf[RX_SIZE], tx_buf[TX_SIZE];


void uartInit(ulong baudrate, uchar parity, uchar stopbits, uchar databits)
{

    PRR     = (1<<PRUSI)|(1<<PRADC);
    ACSR    = (1<<ACD);

#if UART_CFG_INVERT
    UART_CFG_PORT   &= ~(1<<UART_CFG_TXD);
#else
    UART_CFG_PORT   |= (1<<UART_CFG_TXD);
#endif
    UART_DDR    |= (1<<UART_CFG_TXD);
    UART_DDR    &= ~(1<<UART_CFG_RXD);
    
    GIMSK    &= ~(1<<PCIE);
    TCCR0A   = 0;
    TCCR0B   = 0;
    TCCR1    = 0;

    OCR0A    =
    OCR1A    = (F_CPU/64L) / (unsigned int)baudrate - 1;
    OCR1C    = 0;
    DT1A     = -(OCR1A/3);        /* 1.5 sample bit */

    TCCR0A   = 2;                 /* CTC */
    DT1B     = 1;
    EEARL    = 0;
    TIMSK    = (1<<OCIE1A)|(1<<OCIE0A);

    PCMSK    = 1<<UART_CFG_RXD;   /*  PCINTn  */
    GIMSK    |= (1<<PCIE);
}

void uartPoll(void)
{

    /* transmit data    */
    if( TCCR0B==0 && irptr!=uwptr ) {
        EEARL    = 10;      /* tx_bit counter   */
        OCR0B    = tx_buf[irptr];
        irptr    = (irptr+1) & TX_MASK;
        TCNT0    = 0;
        cli();
#if UART_CFG_INVERT
        UART_CFG_PORT   |= (1<<UART_CFG_TXD);       /* start bit */
#else
        UART_CFG_PORT   &= ~(1<<UART_CFG_TXD);      /* start bit */
#endif
        TCCR0B   = 3;       /* start timer0: 1/64 clk */
        sei();
    }

    /* receive data     */
    if( DT1B==0 ) {         /* rx_data ready?   */
        DT1B     = 1;
        uartRxBufAppend( EEDR );
    }
}

uchar uartRxIsBusy(void)
{
    return OCR1C;
}

#endif      /* UART_CFG_HAVE_USART */